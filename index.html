<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
    <canvas id="canvas" style="border: 3px solid red;" height="600" width="300"> </canvas>
    <script>

      const canvas = document.getElementById('canvas')
      const ctx = canvas.getContext('2d')
      var xShift = 0;
      var cols = [3,4,5,6];
      var currentCols = cols
      var rows = [0 ,0 ,0 ,0];
      var toggle = false;
      const colors = ["#F7DC6F","#2471A3", "#2ECC71", "#EB984E", "#AF7AC5", "#D5DBDB", "#784212"]
      currentColor = "#F7DC6F";
      const blocks = {
        "I": [],
        "S": [],
        "Z": [],
        "O": [],
        "L": [],
        "J": [],
        "T": []
      }
      //in block positions, xPos key points to an array of yPos's
      const blockPositions = {0: [25], 1: [25],  2: [25], 3: [25], 4: [25], 5: [25], 6: [25], 7: [25], 8: [25], 9:[25], 10: [25], 11: [25]};

      sinkBlocks = (delay, cols,  rows, color) => {
        ctx.clearRect(0, 0, canvas.width, canvas.height)
        currentCols = cols;

        //checks if any of the blocks touch the stacked blocks
          cols.forEach( (col, idx) => {
            if (blockPositions[col + xShift].slice(-1)[0] === rows[idx] + 1) {
              toggle =  true;
            }
          });

        if (toggle === true) {
          cols.forEach( (col, idx) => {
              blockPositions[col + xShift].push(rows[idx])
          });

          cols = [];
          rows = [0];
          anchorCol = Math.floor(Math.random() * 10);
          cols.push(anchorCol)
          for (blockCount = 1; blockCount < 4; blockCount++) {
            console.log(blockCount)
            switch (Math.floor(Math.random() * 2)) {

              case 0 :
                if (cols.slice(-1)[0] < 11) {
                  cols.push(cols.slice(-1)[0] + 1); //new column
                  rows.push(rows.slice(-1)[0]); //same row
                } else {
                  cols.push(cols.slice(-1)[0]); //same column
                  rows.push(rows.slice(-1)[0] + 1); //new row
                }
                break
              case 1 :
                cols.push(cols.slice(-1)[0]); //same column
                rows.push(rows.slice(-1)[0] + 1); //new row
                break
            }


            // if (cols.slice(-1)[0] < 10) {
            //   cols.push(cols.slice(-1)[0] + 1); //new column
            //   rows.push(rows.slice(-1)[0]); //same row
            // } else {
            //   cols.push(cols.slice(-1)[0]); //same column
            //   rows.push(rows.slice(-1)[0] + 1); //new row
            // }
          }

          toggle = false;
          xShift = 0;
          currentColor = colors[Math.floor(Math.random() * colors.length)]
          return sinkBlocks(300, cols, rows, currentColor)
        }

        //all the stacked blocks
          Object.keys(blockPositions).forEach((x) => {
            return blockPositions[x].forEach((y) => {
              ctx.beginPath();
              ctx.moveTo((x * 25) + 1, (y * 25) - 24);
              ctx.lineTo((x * 25) + 1, (y * 25));
              ctx.lineTo((x * 25) + 23, (y * 25));
              ctx.lineTo((x * 25) + 23, (y * 25) - 24);
              ctx.lineTo((x * 25) + 1, (y * 25) - 24);
              ctx.stroke();
            })
          })


          // current dropping unique block
          cols.forEach( (col, idx) => {
            ctx.fillStyle = currentColor;
            ctx.beginPath();
            ctx.moveTo(((col + xShift) * 25) + 1, (rows[idx] * 25))
            ctx.lineTo(((col + xShift) * 25) + 1, (rows[idx] * 25) + 24)
            ctx.lineTo(((col + xShift) * 25) + 23, (rows[idx] * 25) + 24)
            ctx.lineTo(((col + xShift) * 25) + 23, (rows[idx] * 25))
            ctx.lineTo(((col + xShift) * 25) + 1, (rows[idx] * 25))
            ctx.stroke();
            ctx.fillRect(((col + xShift) * 25) + 1, (rows[idx] * 25), 23, 23)
          })

          toggle = false;
          setTimeout( () => {
            sinkBlocks(delay, currentCols, rows.map((row) => { return row + 1}))
          }, delay);



      }

      document.addEventListener('DOMContentLoaded', () => {
        sinkBlocks(300, cols, rows, currentColor);
      })


      //key movements
      document.addEventListener('keypress', (e) => {
        switch(e.key) {
          case "d" :
            if (currentCols.every((currentCol) => {
              console.log(currentCol + xShift)
              return currentCol + xShift < 11
            })) {
              console.log("d pressed!")
              xShift = xShift + 1;
            }
            break
          case "a" :
            if (currentCols.every((currentCol) => {
              return currentCol + xShift > 0
            })) {
              console.log("a pressed!")
              xShift = xShift - 1;
            }
            break
          case "r" :

          default :
            console.log('wrong key')
        }
      })
    </script>

    <style>

    <style>
  </head>
  <body>

  </body>
</html>
